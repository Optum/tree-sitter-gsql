createQuery = "CREATE" ('OR' 'REPLACE')? "DISTRIBUTED"? "QUERY" queryName "(" (parameterList)? ")" ("FOR" "GRAPH" graphName)? ("RETURNS" "(" baseType | accumType ")")? ("API" "(" stringLiteral ")")? ("SYNTAX" syntaxName)? "{" queryBody "}" ;
interpretQuery := "INTERPRET" "QUERY" "(" ")" ("FOR" "GRAPH" graphName)? ("SYNTAX" syntaxName)? "{" queryBody "}" ;
parameterValueList := parameterValue ("," parameterValue)* ;
parameterValue := parameterConstant | "[" parameterValue ("," parameterValue)* "]" | "(" stringLiteral "," stringLiteral ")" ;
parameterConstant := numeric | stringLiteral | "TRUE" | "FALSE" ;
parameterList := parameterType paramName ("=" constant)? ("," parameterType paramName ("=" constant)?)* ;
syntaxName := name ;
queryBody := (typedefs)? (declExceptStmts)? queryBodyStmts ;
typedefs := (typedef ";")+ ;
declStmts := (declStmt ";")+ ;
declStmt := baseDeclStmt | accumDeclStmt | fileDeclStmt ;
declExceptStmts := (declExceptStmt ";")+ ;
queryBodyStmts := (queryBodyStmt ";")+ ;
queryBodyStmt := assignStmt | vSetVarDeclStmt | declStmts | lAccumAssignStmt | gAccumAssignStmt | gAccumAccumStmt | funcCallStmt | selectStmt | queryBodyCaseStmt | queryBodyIfStmt | queryBodyWhileStmt | queryBodyForEachStmt | "BREAK" | "CONTINUE" | updateStmt | insertStmt | queryBodyDeleteStmt | printStmt | printlnStmt | logStmt | returnStmt | raiseStmt | tryStmt ;
installQuery := "INSTALL" "QUERY" ( "*" | "ALL" | queryName ("," queryName)* ) ;
runQuery := ("RUN" | "INTERPRET") "QUERY" queryName "(" parameterValueList ")" ;
showQuery := "SHOW" "QUERY" queryName ;
dropQuery := "DROP" "QUERY" ( "*" | "ALL" | queryName ("," queryName)* ) ;
stringLiteral := '"' notLit* '"' ;
name := (letter | "_") (letter | digit | "_")* ;
graphName := name ;
queryName := name ;
paramName := name ;
vertexType := name ;
edgeType := name ;
accumName := name ;
vertexSetName := name ;
attrName := name ;
varName := name ;
tupleType := name ;
fieldName := name ;
funcName := name ;
type := baseType | tupleType | accumType ;
baseType := "INT" | "UINT" | "FLOAT" | "DOUBLE" | "STRING" | "BOOL" | "VERTEX" ("<" vertexType ">")? | "EDGE" | "JSONOBJECT" | "JSONARRAY" | "DATETIME" ;
filePath := paramName | stringLiteral ;
typedef := "TYPEDEF" "TUPLE" "<" tupleFields ">" tupleType ;
tupleFields := (baseType fieldName) | (fieldName baseType)("," (baseType fieldName) | (fieldName baseType))* ;
parameterType := baseType | ( "SET" | "BAG" )? "<" baseType ">" | "FILE" ;
accumDeclStmt := accumType localAccumName ("=" constant)?("," localAccumName ("=" constant)?)* | accumType globalAccumName ("=" constant)?("," globalAccumName ("=" constant)?)* ;
localAccumName := "@"accumName ;
globalAccumName := "@@"accumName ;
accumType := "SumAccum" "<" ( "INT" | "FLOAT" | "DOUBLE" | "STRING") ">" | "MaxAccum" "<" ( "INT" | "FLOAT" | "DOUBLE" ) ">" | "MinAccum" "<" ( "INT" | "FLOAT" | "DOUBLE" ) ">" | "AvgAccum" | "OrAccum" | "AndAccum" | "BitwiseOrAccum" | "BitwiseAndAccum" | "ListAccum" "<" type ">" | "SetAccum" "<" elementType ">" | "BagAccum" "<" elementType ">" | "MapAccum" "<" elementType "," (baseType | accumType | tupleType) ">" | "HeapAccum" "<" tupleType ">" "(" simpleSize "," fieldName ("ASC" | "DESC")?("," fieldName ("ASC" | "DESC")?)* ")" | "GroupByAccum" "<" elementType fieldName ("," elementType fieldName)* "," accumType fieldName ("," accumType fieldName)* ">" | "ArrayAccum" "<" accumName ">" ;
elementType := baseType | tupleType ;
gAccumAccumStmt := globalAccumName "+=" expr ;
lAccumAccumStmt := vertexAlias "." localAccumName "+=" expr ;
constant := numeric | stringLiteral | "TRUE" | "FALSE" | "GSQL_UINT_MAX" | "GSQL_INT_MAX" | "GSQL_INT_MIN" | "TO_DATETIME" "(" stringLiteral ")" ;
mathOperator := "*" | "/" | "%" | "+" | "-" | "<<" | ">>" | "&" | " | " ;
condition := expr | expr comparisonOperator expr | expr ( "NOT" )? "IN" setBagExpr | expr "IS" ( "NOT" )? "NULL" | expr "BETWEEN" expr "AND" expr | "(" condition ")" | "NOT" condition | condition ("AND" | "OR") condition | ("TRUE" | "FALSE") | expr ("NOT")? "LIKE" expr;
comparisonOperator := "<" | "<=" | ">" | ">=" | "==" | "!=" ;
aggregator := "COUNT" | "MAX" | "MIN" | "AVG" | "SUM" ;
expr := name | globalAccumName | name "." name | name "." localAccumName ("\'")? | name "." name "." name "(" (argList)? ")" | name "." name "(" (argList)? ")" ( "." "FILTER" "(" condition ")" )? | name ("<" type ("," type)* ">")? "(" (argList)? ")" | name "." localAccumName ("." name "(" (argList)? ")")+ ("." name)? | globalAccumName ("." name "(" (argList)? ")")+ ("." name)? | "COALESCE" "(" (argList)? ")" | aggregator "(" ("DISTINCT")? setBagExpr ")" | "ISEMPTY" "(" setBagExpr ")" | expr mathOperator expr | "-" expr | "(" expr ")" | "(" argList "->" argList ")" | "[" argList "]" | constant | setBagExpr | name "(" argList ")" ;
setBagExpr := name | globalAccumName | name "." name | name "." localAccumName | name "." localAccumName ("." name "(" (argList)? ")")+ | name "." name "(" (argList)? ")" ( "." "FILTER" "(" condition ")" )? | globalAccumName ("." name "(" (argList)? ")")+ | setBagExpr ("UNION" | "INTERSECT" | "MINUS") setBagExpr | "(" argList ")" | "(" setBagExpr ")" ;
baseDeclStmt := baseType name ("=" expr)? ("," name ("=" expr)?)* ;
fileDeclStmt := "FILE" fileVar "(" filePath ")" ;
fileVar := name ;
localVarDeclStmt := baseType varName "=" expr ;
vSetVarDeclStmt := vertexSetName ("(" vertexType ")")?"=" (seedSet | simpleSet | selectStmt) ;
simpleSet := vertexSetName | "(" simpleSet ")" | simpleSet ("UNION" | "INTERSECT" | "MINUS") simpleSet ;
seedSet := "{" (seed ("," seed )*)? "}" ;
seed := '_' | "ANY" | vertexSetName | globalAccumName | vertexType ".*" | paramName | "SelectVertex" selectVertParams ;
selectVertParams := "(" filePath "," columnId "," (columnId | name) ","stringLiteral "," ("TRUE" | "FALSE") ")" ("." "FILTER" "(" condition ")")? ;
columnId := "$"(integer | stringLiteral) ;
assignStmt := name "=" expr | name "." attrName "=" expr ;
attrAccumStmt := name "." attrName "+=" expr ;
lAccumAssignStmt := vertexAlias "." localAccumName ("+=" | "=") expr ;
gAccumAssignStmt := globalAccumName ("+=" | "=") expr ;
loadAccumStmt := globalAccumName "=" "{" "LOADACCUM" loadAccumParams("," "LOADACCUM" loadAccumParams)* "}" ;
loadAccumParams := "(" filePath "," columnId ("," columnId* ","stringLiteral "," ("TRUE" | "FALSE") ")" ("." "FILTER" "(" condition ")")? )? ;
funcCallStmt := name ("<" type ("," type)* ">")? "(" (argList)? ")" | globalAccumName ("." funcName "(" (argList)? ")")+ ;
argList := expr ("," expr)* ;
selectStmt := gsqlSelectBlock | sqlSelectBlock ;
gsqlSelectBlock := gsqlSelectClause fromClause (sampleClause)? (whereClause)? (accumClause)? (postAccumClause)* (havingClause)? (orderClause)? (limitClause)? ;
sqlSelectBlock := fromClause (whereClause)? (groupByClause)? (havingClause)? (orderClause)? (limitClause)? ;
gsqlSelectClause := vertexSetName "=" "SELECT" vertexAlias ;
sqlSelectClause := "SELECT" ("DISTINCT")? columnExpr ("," columnExpr)* "INTO" tableName ;
columnExpr := expr ("AS" columnName)? | aggregator "(" ( "DISTINCT" )? expr ")" ("AS" columnName)?;
columnName := name ;
tableName := name ;
fromClause := "FROM" (step | stepV2 | pathPattern ("," pathPattern)*) ;
step := stepSourceSet ("-" "(" stepEdgeSet ")" ("-" | "->") stepVertexSet)? ;
stepV2 := stepVertexSet ("-" "(" stepEdgeSet ")" "-" stepVertexSet)? ;
stepSourceSet := vertexSetName (":" vertexAlias)? ;
stepEdgeSet := (stepEdgeTypes)? (":" edgeAlias)? ;
stepVertexSet := (stepVertexTypes)? (":" vertexAlias)? ;
alias := (vertexAlias | edgeAlias) ;
vertexAlias := name ;
edgeAlias := name ;
stepEdgeTypes := atomicEdgeType | "(" edgeSetType (" | " edgeSetType)* ")" ;
atomicEdgeType := "_" | "ANY" | edgeSetType ;
edgeSetType := edgeType | paramName | globalAccumName ;
stepVertexTypes := atomicVertexType | "(" vertexSetType (" | " vertexSetType)* ")" ;
atomicVertexType := "_" | "ANY" | vertexSetType ;
vertexSetType := vertexType | paramName | globalAccumName ;
pathPattern := stepVertexSet ("-" "(" pathEdgePattern ")" "-" stepVertexSet)* ;
pathEdgePattern := atomicEdgePattern | "(" pathEdgePattern ")" | pathEdgePattern "." pathEdgePattern | disjPattern | starPattern ;
atomicEdgePattern := atomicEdgeType | atomicEdgeType ">" | "<" atomicEdgeType ;
disjPattern := atomicEdgePattern (" | " atomicEdgePattern)* ;
starPattern := ((atomicEdgePattern)? | "(" disjPattern ")") "*" (starBounds)? ;
starBounds := "CONST_INT" ".." "CONST_INT" | "CONST_INT" ".." | ".." "CONST_INT" | "CONST_INT" ;
sampleClause := "SAMPLE" ( expr | expr "%" ) "EDGE" "WHEN" condition | "SAMPLE" expr "TARGET" "WHEN" condition | "SAMPLE" expr "%" "TARGET" "PINNED" "WHEN" condition ;
whereClause := "WHERE" condition ;
accumClause := (perClauseV2)? "ACCUM" dmlSubStmtList ;
perClauseV2 := "PER" "(" alias ("," alias)? ")" ;
postAccumClause := "POST-ACCUM" dmlSubStmtList ;
dmlSubStmtList := dmlSubStmt ("," dmlSubStmt)* ;
dmlSubStmt := assignStmt | funcCallStmt | gAccumAccumStmt | lAccumAccumStmt | attrAccumStmt | vAccumFuncCall | localVarDeclStmt | dmlSubCaseStmt | dmlSubIfStmt | dmlSubWhileStmt | dmlSubForEachStmt | "BREAK" | "CONTINUE" | insertStmt | dmlSubDeleteStmt | printlnStmt | logStmt ;
vAccumFuncCall := vertexAlias "." localAccumName ("." funcName "(" (argList)? ")")+ ;
groupByClause := "GROUP" "BY" groupExpr ("," groupExpr)* ;
groupExpr := expr ;
havingClause := "HAVING" condition ;
orderClause := "ORDER" "BY" expr ("ASC" | "DESC")? ("," expr ("ASC" | "DESC")?)*;
limitClause := "LIMIT" ( expr | expr "," expr | expr "OFFSET" expr ) ;
queryBodyIfStmt := "IF" condition "THEN" queryBodyStmts("ELSE" "IF" condition "THEN" queryBodyStmts )* ("ELSE" queryBodyStmts )? "END" ;
dmlSubIfStmt := "IF" condition "THEN" dmlSubStmtList("ELSE" "IF" condition "THEN" dmlSubStmtList )* ("ELSE" dmlSubStmtList )? "END" ;
queryBodyCaseStmt := "CASE" ("WHEN" condition "THEN" queryBodyStmts)+ ("ELSE" queryBodyStmts)? "END" | "CASE" expr ("WHEN" constant "THEN" queryBodyStmts)+ ("ELSE" queryBodyStmts)? "END" ;
dmlSubCaseStmt := "CASE" ("WHEN" condition "THEN" dmlSubStmtList)+ ("ELSE" dmlSubStmtList)? "END" | "CASE" expr ("WHEN" constant "THEN" dmlSubStmtList)+ ("ELSE" dmlSubStmtList)? "END" ;
queryBodyWhileStmt := "WHILE" condition ("LIMIT" simpleSize)? "DO" queryBodyStmts "END" ;
dmlSubWhileStmt := "WHILE" condition ("LIMIT" simpleSize)? "DO" dmlSubStmtList "END" ;
simpleSize := integer | varName | paramName ;
queryBodyForEachStmt := "FOREACH" forEachControl "DO" queryBodyStmts "END" ;
dmlSubForEachStmt := "FOREACH" forEachControl "DO" dmlSubStmtList "END" ;
forEachControl := ( iterationVar | "(" keyVar ("," valueVar)+ ")") ("IN" | ":") setBagExpr | iterationVar "IN" "RANGE" "[" expr "," expr"]" ("." "STEP" "(" expr ")")? ;
iterationVar := name ;
keyVar := name ;
valueVar := name ;
pattern := vertexType | edgeType;
queryBodyDeleteStmt := "DELETE" alias "FROM" pattern (whereClause)? ;
dmlSubDeleteStmt := "DELETE" "(" alias ")" ;
updateStmt := "UPDATE" alias "FROM" pattern "SET" dmlSubStmtList (whereClause)? ;
insertStmt := insertVertexStmt | insertEdgeStmt ;
insertVertexStmt := "INSERT" "INTO" (vertexType | name) ( "(" "PRIMARY_ID" ("," attrName)* ")")? "VALUES" "(" ( "_" | expr ) ("," ("_" | expr) )* ")" ;
insertEdgeStmt := "INSERT" "INTO" (edgeType | "EDGE" name)("(" "FROM" "," "TO" ("," attrName)* "")")?VALUES" "(" ( "_" | expr ) (vertexType)?("," ( "_" | expr ) (vertexType)? ("," ("_" | expr))*)? ")" ;
printStmt := "PRINT" printExpr ("," printExpr)* ("WHERE" condition)? ("TO_CSV" (filePath | fileVar))? ;
printExpr := (expr | vExprSet) ( "AS" jsonKey)? | tableName ;
vExprSet := expr "[" vSetProj ("," vSetProj)* "]" ;
vSetProj := expr ( "AS" jsonKey)? ;
jsonKey := name ;
printlnStmt := fileVar ".println" "(" expr ("," expr)* ")" ;
logStmt := "LOG" "(" condition "," argList ")" ;
returnStmt := "RETURN" expr ;
declExceptStmt := "EXCEPTION" exceptVarName "(" errorInt ")" ;
exceptVarName := name ;
errorInt := integer ;
raiseStmt := "RAISE" exceptVarName (errorMsg)? ;
errorMsg := "(" expr ")" ;
tryStmt := "TRY" queryBodyStmts "EXCEPTION" caseExceptBlock+  "END" ";" ;
caseExceptBlock := "WHEN" exceptVarName "THEN" queryBodyStmts ;

(* <?TOKENS?> *)
lowercase := [a-z] ;
uppercase := [A-Z];
letter := lowercase | uppercase ;
digit := [0-9] ;
integer := ("-")? digit+ ;
real := ("-")? ("."digit+) | ("-")?(digit+"."digit*);
numeric := integer | real ;
notLit := [^"&] ;
